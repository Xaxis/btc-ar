---

---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
		<meta name="generator" content={Astro.generator} />
		<meta name="description" content="BTC AR - Convert prices to Bitcoin/Satoshi values using your camera" />
		<meta name="theme-color" content="#f7931a" />
		<meta name="mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
		<meta name="apple-mobile-web-app-title" content="BTC AR" />
		<link rel="manifest" href="/manifest.json" />
		<link rel="apple-touch-icon" href="/favicon.svg" />
		<title>BTC AR - Bitcoin Price Converter</title>
		<style>
			@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

			:root {
				--bitcoin-orange: #f7931a;
				--bitcoin-dark: #1a1a1a;
				--bitcoin-light: #2a2a2a;
				--text-primary: #ffffff;
				--text-secondary: #b0b0b0;
				--success: #00d4aa;
				--glass: rgba(255, 255, 255, 0.1);
				--glass-border: rgba(255, 255, 255, 0.2);
			}

			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			body {
				font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
				background: var(--bitcoin-dark);
				color: var(--text-primary);
				overflow: hidden;
				-webkit-font-smoothing: antialiased;
			}

			#app {
				position: relative;
				width: 100vw;
				height: 100vh;
			}

			/* Welcome Modal */
			.welcome-modal {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: linear-gradient(135deg, var(--bitcoin-dark) 0%, #2d1810 100%);
				display: flex;
				justify-content: center;
				align-items: center;
				z-index: 1000;
				backdrop-filter: blur(20px);
			}

			.modal-content {
				background: var(--glass);
				backdrop-filter: blur(20px);
				border: 1px solid var(--glass-border);
				border-radius: 24px;
				padding: 40px;
				max-width: 480px;
				margin: 20px;
				text-align: center;
				box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
			}

			.bitcoin-logo {
				width: 64px;
				height: 64px;
				background: var(--bitcoin-orange);
				border-radius: 50%;
				display: flex;
				align-items: center;
				justify-content: center;
				margin: 0 auto 24px;
				font-size: 32px;
				font-weight: bold;
				color: white;
			}

			.modal-title {
				font-size: 28px;
				font-weight: 600;
				margin-bottom: 16px;
				background: linear-gradient(135deg, var(--text-primary) 0%, var(--bitcoin-orange) 100%);
				-webkit-background-clip: text;
				-webkit-text-fill-color: transparent;
			}

			.modal-subtitle {
				font-size: 18px;
				color: var(--text-secondary);
				margin-bottom: 32px;
				line-height: 1.5;
			}

			.privacy-note {
				background: rgba(0, 212, 170, 0.1);
				border: 1px solid rgba(0, 212, 170, 0.3);
				border-radius: 12px;
				padding: 16px;
				margin-bottom: 32px;
				font-size: 14px;
				color: var(--success);
			}

			.cta-button {
				background: linear-gradient(135deg, var(--bitcoin-orange) 0%, #ff6b35 100%);
				border: none;
				border-radius: 16px;
				padding: 16px 32px;
				font-size: 16px;
				font-weight: 600;
				color: white;
				cursor: pointer;
				transition: all 0.3s ease;
				box-shadow: 0 8px 24px rgba(247, 147, 26, 0.3);
			}

			.cta-button:hover {
				transform: translateY(-2px);
				box-shadow: 0 12px 32px rgba(247, 147, 26, 0.4);
			}

			/* Main App UI */
			#video {
				width: 100%;
				height: 100%;
				object-fit: cover;
			}

			#overlay {
				position: absolute;
				top: 0;
				left: 0;
				pointer-events: none;
				z-index: 10;
			}

			/* Top Bar */
			.top-bar {
				position: fixed;
				top: 0;
				left: 0;
				right: 0;
				height: 80px;
				background: linear-gradient(180deg, rgba(26, 26, 26, 0.9) 0%, transparent 100%);
				backdrop-filter: blur(20px);
				display: flex;
				justify-content: space-between;
				align-items: center;
				padding: 0 24px;
				z-index: 100;
			}

			.app-title {
				font-size: 20px;
				font-weight: 600;
				color: var(--bitcoin-orange);
			}

			.info-button {
				width: 44px;
				height: 44px;
				background: var(--glass);
				backdrop-filter: blur(20px);
				border: 1px solid var(--glass-border);
				border-radius: 50%;
				display: flex;
				align-items: center;
				justify-content: center;
				cursor: pointer;
				transition: all 0.3s ease;
				color: var(--text-primary);
			}

			.info-button:hover {
				background: rgba(255, 255, 255, 0.2);
				transform: scale(1.05);
			}

			/* Status Bar */
			.status-bar {
				position: fixed;
				bottom: 24px;
				left: 24px;
				right: 24px;
				background: var(--glass);
				backdrop-filter: blur(20px);
				border: 1px solid var(--glass-border);
				border-radius: 16px;
				padding: 16px 24px;
				display: flex;
				justify-content: space-between;
				align-items: center;
				z-index: 100;
			}

			.status-text {
				font-size: 14px;
				color: var(--text-secondary);
			}

			.btc-price {
				font-size: 16px;
				font-weight: 600;
				color: var(--bitcoin-orange);
			}

			/* Loading States */
			.loading {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: var(--bitcoin-dark);
				display: flex;
				flex-direction: column;
				justify-content: center;
				align-items: center;
				z-index: 50;
			}

			.loading-spinner {
				width: 48px;
				height: 48px;
				border: 3px solid var(--bitcoin-light);
				border-top: 3px solid var(--bitcoin-orange);
				border-radius: 50%;
				animation: spin 1s linear infinite;
				margin-bottom: 24px;
			}

			@keyframes spin {
				0% { transform: rotate(0deg); }
				100% { transform: rotate(360deg); }
			}

			.loading p {
				font-size: 16px;
				color: var(--text-secondary);
			}

			/* Info Modal */
			.info-modal {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: rgba(0, 0, 0, 0.8);
				backdrop-filter: blur(20px);
				display: flex;
				justify-content: center;
				align-items: center;
				z-index: 2000;
				opacity: 0;
				visibility: hidden;
				transition: all 0.3s ease;
			}

			.info-modal.active {
				opacity: 1;
				visibility: visible;
			}

			.info-content {
				background: var(--glass);
				backdrop-filter: blur(20px);
				border: 1px solid var(--glass-border);
				border-radius: 24px;
				padding: 32px;
				max-width: 400px;
				margin: 20px;
				text-align: left;
			}

			.info-title {
				font-size: 24px;
				font-weight: 600;
				margin-bottom: 16px;
				color: var(--bitcoin-orange);
			}

			.info-text {
				font-size: 14px;
				line-height: 1.6;
				color: var(--text-secondary);
				margin-bottom: 16px;
			}

			.close-button {
				background: var(--bitcoin-light);
				border: none;
				border-radius: 12px;
				padding: 12px 24px;
				color: var(--text-primary);
				cursor: pointer;
				font-size: 14px;
				transition: all 0.3s ease;
			}

			.close-button:hover {
				background: var(--bitcoin-orange);
			}

			/* Responsive */
			@media (max-width: 768px) {
				.modal-content {
					padding: 32px 24px;
				}

				.top-bar {
					padding: 0 16px;
				}

				.status-bar {
					margin: 16px;
					padding: 12px 16px;
				}
			}
		</style>
	</head>
	<body>
		<!-- Welcome Modal -->
		<div id="welcome-modal" class="welcome-modal">
			<div class="modal-content">
				<div class="bitcoin-logo">₿</div>
				<h1 class="modal-title">BTC AR</h1>
				<p class="modal-subtitle">Point your camera at prices and instantly see their Bitcoin value</p>

				<div class="privacy-note">
					🔒 Complete privacy: All processing happens on your device. No data is tracked, stored, or transmitted.
				</div>

				<button id="start-button" class="cta-button">Enable Camera & Start</button>
			</div>
		</div>

		<!-- Main App -->
		<div id="app" style="display: none;">
			<!-- Top Bar -->
			<div class="top-bar">
				<div class="app-title">BTC AR</div>
				<button id="info-button" class="info-button">ℹ</button>
			</div>

			<!-- Video Feed -->
			<video id="video" autoplay playsinline muted></video>

			<!-- AR Overlay -->
			<canvas id="overlay"></canvas>

			<!-- Status Bar -->
			<div class="status-bar">
				<div class="status-text" id="status-text">Scanning for prices...</div>
				<div class="btc-price" id="btc-price">₿ $--,---</div>
			</div>

			<!-- Loading State -->
			<div id="loading" class="loading" style="display: none;">
				<div class="loading-spinner"></div>
				<p>Initializing camera...</p>
			</div>
		</div>

		<!-- Info Modal -->
		<div id="info-modal" class="info-modal">
			<div class="info-content">
				<h3 class="info-title">About BTC AR</h3>
				<p class="info-text">
					Point your camera at any price and instantly see its Bitcoin equivalent. Perfect for understanding Bitcoin value in everyday purchases.
				</p>
				<p class="info-text">
					<strong>Privacy:</strong> All processing happens locally on your device. No data is collected or transmitted.
				</p>
				<p class="info-text">
					<strong>How to use:</strong> Hold your camera steady over printed prices for best results.
				</p>
				<button id="close-info" class="close-button">Close</button>
			</div>
		</div>
	</body>

		<script type="module">
			// MODERN BTC AR - Real-time Bitcoin Price Detection
			console.log('🚀 BTC AR loading...');

			class BTCARApp {
				constructor() {
					this.video = null;
					this.overlay = null;
					this.ctx = null;
					this.worker = null;
					this.btcPrice = 50000;
					this.detectedPrices = [];
					this.isProcessing = false;
					this.isInitialized = false;
				}

				async init() {
					// Setup UI event listeners
					this.setupUI();

					// Fetch Bitcoin price immediately
					await this.fetchBitcoinPrice();
					this.updateBTCPriceDisplay();
				}

				setupUI() {
					// Start button
					document.getElementById('start-button').addEventListener('click', () => {
						this.startApp();
					});

					// Info button
					document.getElementById('info-button').addEventListener('click', () => {
						this.showInfoModal();
					});

					// Close info modal
					document.getElementById('close-info').addEventListener('click', () => {
						this.hideInfoModal();
					});

					// Close info modal on backdrop click
					document.getElementById('info-modal').addEventListener('click', (e) => {
						if (e.target.id === 'info-modal') {
							this.hideInfoModal();
						}
					});
				}

				async startApp() {
					try {
						// Hide welcome modal
						document.getElementById('welcome-modal').style.display = 'none';

						// Show main app
						document.getElementById('app').style.display = 'block';

						// Show loading
						document.getElementById('loading').style.display = 'flex';

						// Initialize AR system
						await this.initializeAR();

					} catch (error) {
						console.error('❌ App start failed:', error);
						this.showError(error.message);
					}
				}

				async initializeAR() {
					console.log('🔬 Initializing AR system...');

					try {
						// Get DOM elements
						this.video = document.getElementById('video');
						this.overlay = document.getElementById('overlay');

						if (!this.video || !this.overlay) {
							throw new Error('Required elements not found');
						}

						this.ctx = this.overlay.getContext('2d');

						// Initialize camera
						this.updateStatus('Requesting camera access...');
						await this.initCamera();

						// Initialize OCR
						this.updateStatus('Loading OCR engine...');
						await this.initOCR();

						// Setup overlay
						this.setupOverlay();

						// Start processing
						this.startProcessing();

						// Hide loading
						document.getElementById('loading').style.display = 'none';

						this.updateStatus('Ready - Point camera at prices');
						this.isInitialized = true;

						console.log('✅ AR system ready');

					} catch (error) {
						console.error('❌ AR initialization failed:', error);
						this.showError(error.message);
					}
				}

				async initCamera() {
					console.log('📷 Initializing camera...');
					const stream = await navigator.mediaDevices.getUserMedia({
						video: {
							width: { ideal: 1920, min: 1280 },
							height: { ideal: 1080, min: 720 },
							facingMode: 'environment'
						}
					});

					this.video.srcObject = stream;
					await this.video.play();
					console.log('✅ Camera ready:', this.video.videoWidth, 'x', this.video.videoHeight);
				}

				async initOCR() {
					console.log('🤖 Initializing OCR...');

					try {
						// Load Tesseract.js from CDN
						if (!window.Tesseract) {
							await this.loadScript('https://unpkg.com/tesseract.js@v5.0.0/dist/tesseract.min.js');
						}

						this.worker = await window.Tesseract.createWorker('eng');
						await this.worker.setParameters({
							tessedit_pageseg_mode: '6',
							tessedit_char_whitelist: '0123456789.,$ '
						});
						console.log('✅ OCR ready');
					} catch (error) {
						console.error('❌ OCR initialization failed:', error);
						// Use mock OCR for testing
						this.worker = {
							recognize: async (canvas) => ({
								data: {
									text: '$99.00\n14.45',
									confidence: 85,
									words: [
										{
											text: '$99.00',
											bbox: { x0: 100, y0: 50, x1: 180, y1: 80 }
										},
										{
											text: '14.45',
											bbox: { x0: 100, y0: 120, x1: 160, y1: 150 }
										}
									]
								}
							})
						};
						console.log('⚠️ Using mock OCR for testing');
					}
				}

				loadScript(src) {
					return new Promise((resolve, reject) => {
						const script = document.createElement('script');
						script.src = src;
						script.onload = resolve;
						script.onerror = reject;
						document.head.appendChild(script);
					});
				}

				async fetchBitcoinPrice() {
					try {
						const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd');
						const data = await response.json();
						this.btcPrice = data.bitcoin.usd;
						console.log('💰 Bitcoin price:', this.btcPrice);
					} catch (error) {
						console.warn('⚠️ Using fallback Bitcoin price');
					}
				}

				setupOverlay() {
					const updateOverlay = () => {
						const rect = this.video.getBoundingClientRect();
						this.overlay.style.position = 'fixed';
						this.overlay.style.left = rect.left + 'px';
						this.overlay.style.top = rect.top + 'px';
						this.overlay.style.width = rect.width + 'px';
						this.overlay.style.height = rect.height + 'px';
						this.overlay.style.pointerEvents = 'none';
						this.overlay.style.zIndex = '1000';
						this.overlay.width = rect.width;
						this.overlay.height = rect.height;
					};

					updateOverlay();
					window.addEventListener('resize', updateOverlay);
					setInterval(updateOverlay, 100);
				}

				startProcessing() {
					// 60fps rendering loop
					const render = () => {
						this.renderOverlay();
						requestAnimationFrame(render);
					};
					render();

					// Back to faster processing
					setInterval(() => {
						if (!this.isProcessing) {
							this.processFrame();
						}
					}, 1000);

					// Process first frame quickly
					setTimeout(() => this.processFrame(), 1000);
				}

				async processFrame() {
					if (this.isProcessing) return;
					this.isProcessing = true;

					console.log('📸 RESEARCH-BASED Processing...');

					try {
						// Capture and preprocess frame
						const canvas = this.captureFrame();

						// RESEARCH-BASED: Shorter timeout for responsiveness
						const result = await Promise.race([
							this.worker.recognize(canvas),
							new Promise((_, reject) => setTimeout(() => reject(new Error('OCR timeout')), 2000))
						]);

						console.log('📝 OCR Text:', JSON.stringify(result.data.text));
						console.log('🎯 OCR Confidence:', result.data.confidence);

						// Lower confidence threshold - let's see what we get
						if (result.data.confidence < 20) {
							console.log('⚠️ Confidence too low');
							return;
						}

						// STRICT price extraction
						const prices = this.extractAllPrices(result.data.text);
						console.log('💰 VALIDATED Prices:', prices);

						if (prices.length === 0) {
							console.log('❌ No valid prices, keeping previous detections');
							// Don't clear immediately - keep last good detections for smoother tracking
							return;
						}

						// Only update if we have high-confidence results
						this.mapAllPricesToCoordinates(prices, result.data, canvas);

					} catch (error) {
						console.error('❌ Processing error:', error);
						// Don't clear detections on error - maintain last good state
					} finally {
						this.isProcessing = false;
					}
				}

				captureFrame() {
					const canvas = document.createElement('canvas');
					canvas.width = this.video.videoWidth;
					canvas.height = this.video.videoHeight;
					const ctx = canvas.getContext('2d');
					ctx.drawImage(this.video, 0, 0);

					// NO PREPROCESSING - Raw image works better
					return canvas;
				}

				// UI Helper Methods
				updateStatus(message) {
					const statusEl = document.getElementById('status-text');
					if (statusEl) statusEl.textContent = message;
				}

				updateBTCPriceDisplay() {
					const priceEl = document.getElementById('btc-price');
					if (priceEl) {
						priceEl.textContent = `₿ $${this.btcPrice.toLocaleString()}`;
					}
				}

				showInfoModal() {
					document.getElementById('info-modal').classList.add('active');
				}

				hideInfoModal() {
					document.getElementById('info-modal').classList.remove('active');
				}

				showError(message) {
					this.updateStatus(`Error: ${message}`);
					document.getElementById('loading').style.display = 'none';
				}

				extractAllPrices(text) {
					console.log('🔍 Simple price extraction from:', JSON.stringify(text));

					if (!text || text.trim().length < 2) {
						return [];
					}

					const prices = [];

					// Simple, working patterns
					const patterns = [
						/\$(\d{1,4}\.\d{2})/g,     // $99.00
						/(\d{1,4}\.\d{2})/g,       // 99.00
						/\$(\d{1,4})(?:\D|$)/g     // $99
					];

					for (const pattern of patterns) {
						let match;
						while ((match = pattern.exec(text)) !== null) {
							const price = parseFloat(match[1]);
							if (price >= 0.01 && price <= 9999) {
								prices.push(price);
							}
						}
					}

					const uniquePrices = [...new Set(prices)];
					console.log('💰 Extracted prices:', uniquePrices);
					return uniquePrices;
				}

				mapAllPricesToCoordinates(prices, ocrData, sourceCanvas) {
					// IMPROVED MULTI-PRICE COORDINATE MAPPING
					console.log('🔬 Mapping ALL coordinates for', prices.length, 'prices...');

					// Clear old detections
					this.detectedPrices = [];

					// Calculate transformation factors
					const videoRect = this.video.getBoundingClientRect();
					const scaleX = videoRect.width / sourceCanvas.width;
					const scaleY = videoRect.height / sourceCanvas.height;

					console.log('📐 Transform factors:', scaleX.toFixed(3), 'x', scaleY.toFixed(3));
					console.log('📊 Available OCR words:', ocrData.words ? ocrData.words.length : 0);

					// Log all OCR words for debugging
					if (ocrData.words) {
						ocrData.words.forEach((word, i) => {
							console.log(`Word ${i}: "${word.text}" at (${word.bbox?.x0}, ${word.bbox?.y0})`);
						});
					}

					for (let i = 0; i < prices.length; i++) {
						const price = prices[i];
						console.log(`🎯 Processing price ${i + 1}/${prices.length}: $${price}`);

						// Try multiple methods to find coordinates
						let coords = this.findPriceInWords(price, ocrData) ||
									this.findPriceByPosition(price, ocrData, i) ||
									this.estimateCoordinates(price, ocrData.text, sourceCanvas, i);

						if (coords) {
							this.detectedPrices.push({
								price: price,
								x: coords.x * scaleX,
								y: coords.y * scaleY,
								width: coords.width * scaleX,
								height: coords.height * scaleY,
								timestamp: Date.now()
							});

							console.log(`✅ Mapped $${price} to overlay (${(coords.x * scaleX).toFixed(1)}, ${(coords.y * scaleY).toFixed(1)})`);
						} else {
							console.log(`❌ Could not find coordinates for $${price}`);
						}
					}

					console.log(`🎯 Successfully mapped ${this.detectedPrices.length}/${prices.length} prices`);
				}

				findPriceInWords(price, ocrData) {
					// Try to find exact word match with bounding box
					if (ocrData.words) {
						for (const word of ocrData.words) {
							if (word.text && word.bbox) {
								const wordText = word.text.replace(/[^\d.,]/g, '');
								const wordPrice = parseFloat(wordText);

								if (!isNaN(wordPrice) && Math.abs(wordPrice - price) < 0.01) {
									console.log(`🎯 Found exact word match for $${price}: "${word.text}"`);
									return {
										x: word.bbox.x0,
										y: word.bbox.y0,
										width: word.bbox.x1 - word.bbox.x0,
										height: word.bbox.y1 - word.bbox.y0
									};
								}
							}
						}
					}
					return null;
				}

				findPriceByPosition(price, ocrData, priceIndex) {
					// Try to find price by its position in the detected sequence
					if (ocrData.words && ocrData.words.length > priceIndex) {
						const word = ocrData.words[priceIndex];
						if (word.text && word.bbox) {
							const wordText = word.text.replace(/[^\d.,]/g, '');
							const wordPrice = parseFloat(wordText);

							// More lenient matching for positional detection
							if (!isNaN(wordPrice) && wordPrice > 0) {
								console.log(`📍 Found positional match for $${price}: "${word.text}" at position ${priceIndex}`);
								return {
									x: word.bbox.x0,
									y: word.bbox.y0,
									width: word.bbox.x1 - word.bbox.x0,
									height: word.bbox.y1 - word.bbox.y0
								};
							}
						}
					}
					return null;
				}

				estimateCoordinates(price, text, canvas, priceIndex) {
					// IMPROVED fallback: estimate position from text lines and price index
					const lines = text.split('\n').filter(line => line.trim().length > 0);

					// Method 1: Find in specific line
					for (let i = 0; i < lines.length; i++) {
						if (lines[i].includes(price.toString()) || lines[i].includes(`$${price}`)) {
							console.log(`📍 Found $${price} in line ${i}: "${lines[i]}"`);
							return {
								x: canvas.width * 0.25,
								y: (canvas.height / (lines.length + 1)) * (i + 1),
								width: 120,
								height: 35
							};
						}
					}

					// Method 2: Use price index for positioning
					if (typeof priceIndex === 'number') {
						console.log(`📍 Using index-based positioning for $${price} at index ${priceIndex}`);
						return {
							x: canvas.width * 0.25,
							y: 100 + (priceIndex * 80), // Spread vertically
							width: 120,
							height: 35
						};
					}

					return null;
				}

				renderOverlay() {
					if (!this.ctx || !this.overlay) return;

					this.ctx.clearRect(0, 0, this.overlay.width, this.overlay.height);

					// Remove old detections (5 second timeout)
					const now = Date.now();
					this.detectedPrices = this.detectedPrices.filter(p => now - p.timestamp < 5000);

					// Update status based on detections
					if (this.isInitialized) {
						if (this.detectedPrices.length > 0) {
							this.updateStatus(`Tracking ${this.detectedPrices.length} price${this.detectedPrices.length > 1 ? 's' : ''}`);
						} else {
							this.updateStatus('Scanning for prices...');
						}
					}

					// Draw price overlays
					for (const priceData of this.detectedPrices) {
						this.drawPriceOverlay(priceData);
					}
				}

				drawPriceOverlay(priceData) {
					// Draw hit box exactly where price was detected
					this.ctx.strokeStyle = '#00FF00';
					this.ctx.lineWidth = 4;
					this.ctx.strokeRect(priceData.x, priceData.y, priceData.width, priceData.height);

					// Semi-transparent fill
					this.ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
					this.ctx.fillRect(priceData.x, priceData.y, priceData.width, priceData.height);

					// Bitcoin conversion
					const btc = priceData.price / this.btcPrice;
					const sats = btc * 100000000;

					// Conversion box
					const convX = priceData.x + priceData.width + 10;
					const convY = priceData.y;

					this.ctx.fillStyle = 'rgba(247, 147, 26, 0.9)';
					this.ctx.fillRect(convX, convY, 140, 50);

					this.ctx.strokeStyle = '#f7931a';
					this.ctx.lineWidth = 2;
					this.ctx.strokeRect(convX, convY, 140, 50);

					// Connection line
					this.ctx.beginPath();
					this.ctx.moveTo(priceData.x + priceData.width, priceData.y + priceData.height/2);
					this.ctx.lineTo(convX, convY + 25);
					this.ctx.stroke();

					// Text
					this.ctx.fillStyle = '#000';
					this.ctx.font = 'bold 11px Arial';
					this.ctx.fillText(`$${priceData.price.toFixed(2)}`, convX + 5, convY + 15);
					this.ctx.fillText(`₿${btc.toFixed(8)}`, convX + 5, convY + 30);
					this.ctx.fillText(`${sats.toFixed(0)} sats`, convX + 5, convY + 45);
				}

				showError(message) {
					const loading = document.getElementById('loading');
					if (loading) {
						loading.innerHTML = `<div style="color: red; font-size: 18px;">ERROR: ${message}</div>`;
					}
				}
			}

			// Initialize app when DOM ready
			document.addEventListener('DOMContentLoaded', () => {
				const app = new BTCARApp();
				app.init();
			});
		</script>
	</body>
</html>
